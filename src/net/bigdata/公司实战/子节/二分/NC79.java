/*
 * Copyright © 2018-2021 me.100.
 *
 * This file is part of Java_rep project.
 * It can not be copied and/or distributed without the express
 * permission of bigdata group.
 */
package net.bigdata.公司实战.子节.二分;

/**
 * Java_rep: NC79 丑数
 *
 * @author wuyang
 * @version 1.2.0, 2021-12-19 20:08
 * @since 1.2.0, 2021-12-19 20:08
 */
public class NC79 {
    /**
     * 说一下我对三指针的理解吧。 和动态规划没有关系。
     *
     * 我们知道，丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是：
     * A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}
     *
     * B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}
     *
     * C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}
     *
     * 那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。
     *
     * 合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。
     *
     * 回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：
     *
     * A ： {1*2......}
     *
     * B ： {1*3......}
     *
     * C ： {1*5......}
     *
     * 假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成{1,2}了，对应的ABC数组就分别变成了：
     *
     * A ： {1*2, 2*2......}
     *
     * B ： {1*3, 2*3......}
     *
     * C ： {1*5, 2*5......}
     *
     * 此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向B[0]和C[0]，然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。
     *
     * 此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较A[i]=ugly[i]*2，B[j]=ugly[j]*3和C[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。
     *
     * @param n
     * @return
     */
    public static int nthUglyNumber(int n) {
        if (n <= 0) {
            return -1;
        }
        int[] dp = new int[n];
        dp[0] = 1;
        int id2 = 0, id3 = 0, id5 = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = Math.min(dp[id2] * 2, Math.min(dp[id3] * 3, dp[id5] * 5));
            // 这里不用else if的原因是有可能id2(3) * 2 == id3(2) * 3
            // 这种情况两个指针都要后移
            if (dp[id2] * 2 == dp[i]) {
                id2++;
            }
            if (dp[id3] * 3 == dp[i]) {
                id3++;
            }
            if (dp[id5] * 5 == dp[i]) {
                id5++;
            }
        }
        return dp[n - 1];
    }

    public static void main(String[] args) {
        System.out.println(nthUglyNumber(10));
    }
}
